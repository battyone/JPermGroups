package math.algebra.permgroup;

import static com.google.common.base.Preconditions.checkArgument;

import com.google.common.base.Joiner;
import com.google.common.base.Predicate;
import com.google.common.collect.Collections2;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;

import java.util.AbstractSet;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import javax.annotation.Nullable;

import math.structures.permutation.Permutation;
import math.structures.permutation.Permutations;

public class PermutationGroup<E> extends AbstractSet<Permutation<E>> {
  private static <E> List<Predicate<Permutation<E>>>
      basicFilters(Set<E> domain) {
    ImmutableList.Builder<Predicate<Permutation<E>>> builder =
        ImmutableList.builder();
    for (final E e : domain) {
      builder.add(new Predicate<Permutation<E>>() {
        @Override public boolean apply(Permutation<E> input) {
          return input.stabilizes(e);
        }
      });
    }
    return builder.build();
  }

  private final Permutation<E> id;
  private final CosetTables<E> cosetTables;
  private final Collection<Permutation<E>> generators;

  /**
   * Constructs the permutation group generated by the specified collection of
   * generators.
   */
  PermutationGroup(Collection<Permutation<E>> generators) {
    this(generators, CosetTables.create(generators));
  }

  /**
   * Constructs a permutation group with the specified generators and coset
   * tables.
   */
  PermutationGroup(Collection<Permutation<E>> generators,
      CosetTables<E> cosetTables) {
    this.generators = ImmutableList.copyOf(generators);
    this.id = Permutations.identity();
    this.cosetTables = cosetTables;
  }

  /**
   * Constructs the permutation group generated by the permutations in the
   * specified coset tables.
   */
  PermutationGroup(CosetTables<E> cosetTables) {
    this(ImmutableSet.copyOf(Iterables.concat(cosetTables.getTables())),
        cosetTables);
  }

  @Override public boolean contains(@Nullable Object o) {
    if (o instanceof Permutation) {
      @SuppressWarnings("unchecked")
      Permutation<E> p = (Permutation) o;
      return cosetTables.generates(p);
    }
    return false;
  }

  @SuppressWarnings("unchecked") @Override public boolean containsAll(
      Collection<?> c) {
    if (c instanceof PermutationGroup) {
      return ((PermutationGroup) c).isSubgroupOf(this);
    } else if (c instanceof LeftCoset) {
      LeftCoset<?> coset = (LeftCoset<?>) c;
      return containsAll(coset.getGroup())
          && contains(coset.getRepresentative());
    }
    return super.containsAll(c);
  }

  public Set<E> support() {
    return cosetTables.getSupport();
  }

  @Override public boolean equals(@Nullable Object o) {
    if (o instanceof PermutationGroup) {
      @SuppressWarnings("unchecked")
      PermutationGroup<E> g = (PermutationGroup) o;
      return size() == g.size() && g.containsAll(generators);
    }
    return super.equals(o);
  }

  /**
   * Returns the permutation group generated by this group and the specified
   * generators.
   */
  public PermutationGroup<E> extend(Iterable<Permutation<E>> newGenerators) {
    List<Permutation<E>> newGs = Lists.newArrayList();
    for (Permutation<E> g : newGenerators) {
      if (!contains(g)) {
        newGs.add(g);
      }
    }
    if (newGs.isEmpty()) {
      return this;
    }
    newGs.addAll(generators);
    return new PermutationGroup<E>(newGs, cosetTables.extend(newGs));
  }

  /**
   * Returns this permutation group extended to a larger domain.
   */
  public PermutationGroup<E> extend(Set<E> newDomain) {
    return extend(ImmutableSet.copyOf(newDomain));
  }

  /**
   * Returns a collection of generators for this permutation group.
   */
  public Collection<Permutation<E>> generators() {
    return generators;
  }

  /**
   * Returns the identity in this group.
   */
  public Permutation<E> identity() {
    return id;
  }

  @Override public boolean isEmpty() {
    return false;
  }

  /**
   * Returns true if
   * 
   * @param g
   * @return
   */
  public boolean isSubgroupOf(PermutationGroup<E> g) {
    return size() <= g.size() && g.containsAll(generators());
  }

  @Override public Iterator<Permutation<E>> iterator() {
    return cosetTables.generatedIterator();
  }

  @Override public int size() {
    return cosetTables.size();
  }

  /**
   * Returns the subgroup of elements satisfying all of the specified filters.
   */
  public PermutationGroup<E> subgroup(
      List<? extends Predicate<? super Permutation<E>>> filters) {
    if (filters.isEmpty()) {
      return this;
    }
    return new PermutationGroup<E>(CosetTables.subgroupTables(generators,
        filters));
  }

  /**
   * Returns the subgroup of elements satisfying the specified filter.
   */
  public PermutationGroup<E> subgroup(Predicate<? super Permutation<E>> filter) {
    return subgroup(Collections.singletonList(filter));
  }

  @Override public String toString() {
    StringBuilder builder = new StringBuilder(generators.size() * 10);
    builder.append('<');
    Joiner.on(", ").appendTo(builder, generators);
    builder.append('>');
    return builder.toString();
  }

  CosetTables<E> getCosetTables() {
    return cosetTables;
  }
}
